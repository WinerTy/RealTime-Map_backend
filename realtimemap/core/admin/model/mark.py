from datetime import datetime
from typing import Dict, Any, TYPE_CHECKING

from starlette.requests import Request
from starlette_admin import HasOne, IntegerField, DateTimeField
from starlette_admin.contrib.sqla import ModelView
from starlette_admin.exceptions import FormValidationError

from core.admin.fields import GeomField
from core.admin.fields.geohash_field import GeoHashField
from core.app.socket import sio
from crud.mark import MarkRepository
from models import Mark
from models.mark.schemas import ActionType
from services.notification import MarkNotificationService

if TYPE_CHECKING:
    from sqlalchemy.ext.asyncio import AsyncSession


class AdminMark(ModelView):
    fields = [
        Mark.id,
        GeomField(
            "geom",
            srid=4326,
            required=True,
            help_text="Latitude/Longitude. Example: 61.250, 73.3960.\nMap integrate in future!",
        ),
        GeoHashField(
            "geohash",
            required=False,
            help_text="Geohash autogenerated by coordinates out geom field",
            read_only=True,
        ),
        Mark.mark_name,
        HasOne("owner", identity="user", required=True),
        Mark.additional_info,
        HasOne("category", identity="category", required=True),
        IntegerField("duration", min=12, max=48, step=12, required=True),
        DateTimeField("start_at", label="Start at", required=True),
        DateTimeField(
            "end_at", label="End at", exclude_from_create=True, exclude_from_edit=True
        ),
        Mark.photo,
        Mark.is_ended,
    ]
    exclude_fields_from_create = [Mark.is_ended]

    async def before_create(
        self, request: Request, data: Dict[str, Any], obj: Mark
    ) -> None:
        pass

    async def validate(self, request: Request, data: Dict[str, Any]) -> None:
        errors: Dict[str, str] = dict()

        if data["geom"] is None:
            errors["geom"] = "Geom required. Example: 90, 180"

        if request.state.action != "EDIT":
            if data["start_at"] < datetime.now():
                errors["start_at"] = "Start at is before current time"

        if data["owner"] is None:
            errors["owner"] = "Not valid owner"

        if data["category"] is None:
            errors["category"] = "Not valid category"

        if len(errors) > 0:
            raise FormValidationError(errors)

        return await super().validate(request, data)

    @staticmethod  # TODO Maybe rework!
    async def send_notify_mark_action(
        request: Request, mark: Mark, action_type: str
    ) -> None:
        session: "AsyncSession" = request.state.session
        mark_repo = MarkRepository(session)
        notify_service = MarkNotificationService(mark_repo, sio)
        await notify_service.notify_mark_action(mark, action_type, request)

    async def after_create(self, request: Request, obj: Mark) -> None:
        await self.send_notify_mark_action(request, obj, ActionType.CREATE.value)

    async def after_edit(self, request: Request, obj: Mark) -> None:
        await self.send_notify_mark_action(request, obj, ActionType.UPDATE.value)

    async def after_delete(self, request: Request, obj: Any) -> None:
        await self.send_notify_mark_action(request, obj, ActionType.DELETE.value)
